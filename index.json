[{"content":"Pytorch在保存模型时，会把训练过程中使用的设备号（GPU:0, CPU等）也一起保存下来，当load保存的模型时，会默认把权重加载到训练时使用的设备上，要修改加载到的卡号可以如下：\ntorch.load('your_model.pth', map_location=lambda storage, loc : storage.cuda(1))\n","permalink":"https://sqdtss.github.io/posts/pytorch%E8%BD%BD%E5%85%A5%E4%BF%9D%E5%AD%98%E7%9A%84%E6%A8%A1%E5%9E%8B%E6%9B%B4%E6%8D%A2gpu%E5%8D%A1%E5%8F%B7%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AEmap_location/","summary":"Pytorch在保存模型时，会把训练过程中使用的设备号（GPU:0, CPU等）也一起保存下来，当load保存的模型时，会默认把权重加载到训练","title":"Pytorch载入保存的模型更换gpu卡号如何设置map_location"},{"content":"什么是跨域请求 转自：https://www.jianshu.com/p/f880878c1398 概述 在 HTML 中，\u0026lt;a\u0026gt;, \u0026lt;form\u0026gt;, \u0026lt;img\u0026gt;, \u0026lt;script\u0026gt;, \u0026lt;iframe\u0026gt;, \u0026lt;link\u0026gt; 等标签以及 Ajax 都可以指向一个资源地址，而所谓的跨域请求就是指：当前发起请求的域与该请求指向的资源所在的域不一样。这里的域指的是这样的一个概念：若协议 + 域名 + 端口号均相同，那么就是同域。\n跨域请求的安全问题 通常，浏览器会对上面提到的跨域请求作出限制。浏览器之所以要对跨域请求作出限制，是出于安全方面的考虑，因为跨域请求有可能被不法分子利用来发动 CSRF攻击。\nCSRF（Cross-site request forgery），中文名称：跨站请求伪造，也被称为：one click attack/session riding，缩写为：CSRF/XSRF。CSRF攻击者在用户已经登录目标网站之后，诱使用户访问一个攻击页面，利用目标网站对用户的信任，以用户身份在攻击页面对目标网站发起伪造用户操作的请求，达到攻击目的。\n跨域解决方法 虽然在安全层面上同源限制是必要的，但有时同源策略会对我们的合理用途造成影响，为了避免开发的应用受到限制，有多种方式可以绕开同源策略，下面介绍的是经常使用的 JSONP, CORS 方法。\nJSONP 原理：  JSONP 是一种非官方的跨域数据交互协议 JSONP 本质上是利用 \u0026lt;script\u0026gt;\u0026lt;img\u0026gt;\u0026lt;iframe\u0026gt; 等标签不受同源策略限制，可以从不同域加载并执行资源的特性，来实现数据跨域传输。 JSONP由两部分组成：回调函数和数据。回调函数是当响应到来时应该在页面中调用的函数，而数据就是传入回调函数中的JSON数据。 JSONP 的理念就是，与服务端约定好一个回调函数名，服务端接收到请求后，将返回一段 Javascript，在这段 Javascript 代码中调用了约定好的回调函数，并且将数据作为参数进行传递。当网页接收到这段 Javascript 代码后，就会执行这个回调函数，这时数据已经成功传输到客户端了。  示例： 首先当前页面中声明有这样的一个函数，它将作为 JSONP 的回调函数处理作为函数参数传入的数据\n\u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; function dosomething(jsondata){ //处理获得的json数据 } \u0026lt;/script\u0026gt; 然后，我们就可以借助 \u0026lt;script\u0026gt;\u0026lt;img\u0026gt;\u0026lt;iframe\u0026gt; 等标签可以引入不同域资源的特性，将需要发送的请求的路径作为src参数，其中需要注意的是：需要告知服务端回调函数的函数名。\n\u0026lt;script src=\u0026#34;http://example.com/data.php?callback=dosomething\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 这时服务端在返回数据的时候，就会返回一端 Javascript 代码，在 Javascript代码中调用了回调函数，并且需要返回的数据作为回调函数的参数\ndosomething([\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;c\u0026#39;]); 最后页面成功加载了刚才指定路径的资源后，将会执行该 Javascript 代码，dosomething函数将执行，这时一次跨域请求完成。\n另外，如果页面引入了 jQuery，那么可以通过它封装的方法很方便的实现JSONP操作了\n// Using YQL and JSONP $.ajax({ url: \u0026#34;http://query.yahooapis.com/v1/public/yql\u0026#34;, // The name of the callback parameter, as specified by the YQL service  jsonp: \u0026#34;callback\u0026#34;, // Tell jQuery we\u0026#39;re expecting JSONP  dataType: \u0026#34;jsonp\u0026#34;, // Tell YQL what we want and that we want JSON  data: { q: \u0026#34;select title,abstract,url from search.news where query=\\\u0026#34;cat\\\u0026#34;\u0026#34;, format: \u0026#34;json\u0026#34; }, // Work with the response  success: function( response ) { console.log( response ); // server response  } }); 优缺点： JSONP 的优点是：它不像XMLHttpRequest对象实现的Ajax请求那样受到同源策略的限制；它的兼容性更好，在更加古老的浏览器中都可以运行。\nJSONP 的缺点是：它只支持 GET 请求，而不支持 POST 请求等其他类型的 HTTP 请求\nCORS 介绍 跨源资源共享 Cross-Origin Resource Sharing(CORS) 是一个新的 W3C 标准，它新增的一组HTTP首部字段，允许服务端其声明哪些源站有权限访问哪些资源。换言之，它允许浏览器向声明了 CORS 的跨域服务器，发出 XMLHttpReuest 请求，从而克服 Ajax 只能同源使用的限制。\n另外，规范也要求对于非简单请求，浏览器必须首先使用 OPTION 方法发起一个预检请求(preflight request)，从而获知服务端是否允许该跨域请求，在服务器确定允许后，才发起实际的HTTP请求。对于简单请求、非简单请求以及预检请求的详细资料可以阅读HTTP访问控制（CORS） 。\nHTTP 协议 Header 简析 下面对 CORS 中新增的 HTTP 首部字段进行简析：\n  Access-Control-Allow-Origin\n响应首部中可以携带这个头部表示服务器允许哪些域可以访问该资源，其语法如下：\nAccess-Control-Allow-Origin: \u0026lt;origin\u0026gt; | * 其中，origin 参数的值指定了允许访问该资源的外域 URI。对于不需要携带身份凭证的请求，服务器可以指定该字段的值为通配符，表示允许来自所有域的请求。\n  Access-Control-Allow-Methods\n该首部字段用于预检请求的响应，指明实际请求所允许使用的HTTP方法。其语法如下：\nAccess-Control-Allow-Methods: \u0026lt;method\u0026gt;[, \u0026lt;method\u0026gt;]*   Access-Control-Allow-Headers\n该首部字段用于预检请求的响应。指明了实际请求中允许携带的首部字段。其语法如下：\nAccess-Control-Allow-Headers: \u0026lt;field-name\u0026gt;[, \u0026lt;field-name\u0026gt;]*   Access-Control-Max-Age\n该首部字段用于预检请求的响应，指定了预检请求能够被缓存多久，其语法如下：\nAccess-Control-Max-Age: \u0026lt;delta-seconds\u0026gt;   Access-Control-Allow-Credentials\n该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。其语法如下：\nAccess-Control-Allow-Credentials: true 另外，如果要把 Cookie 发送到服务器，除了服务端要带上Access-Control-Allow-Credentials首部字段外，另一方面请求中也要带上withCredentials属性。\n但是需要注意的是：如果需要在 Ajax 中设置和获取 Cookie，那么Access-Control-Allow-Origin首部字段不能设置为* ，必须设置为具体的 origin 源站。详细可阅读文章CORS 跨域 Cookie 的设置与获取\n  Origin\n该首部字段表明预检请求或实际请求的源站。不管是否为跨域请求，Origin字段总是被发送。其语法如下：\nOrigin: \u0026lt;origin\u0026gt;   Access-Control-Request-Method\n该首部字段用于预检请求。其作用是，将实际请求所使用的 HTTP 方法告诉服务器。其语法如下：\nAccess-Control-Request-Method: \u0026lt;method\u0026gt;   Access-Control-Request-Headers\n该首部字段用于预检请求。其作用是，将实际请求所携带的首部字段告诉服务器。其语法如下：\nAccess-Control-Request-Headers: \u0026lt;field-name\u0026gt;[, \u0026lt;field-name\u0026gt;]*   与 JSONP 的比较  JSONP 只能实现 GET 请求，而 CORS 支持所有类型的 HTTP 请求 使用 CORS ，开发者可以是使用普通的 XMLHttpRequest 发起请求和获取数据，比起 JSONP 有更好的错误处理 虽然绝大多数现代的浏览器都已经支持 CORS，但是 CORS 的兼容性比不上 JSONP，一些比较老的浏览器只支持 JSONP  Reference  Http跨域请求 浅谈CSRF攻击方式 同源策略详解 详解js跨域问题 HTTP访问控制（CORS） 跨域资源共享 CORS 详解  ","permalink":"https://sqdtss.github.io/posts/%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82/","summary":"什么是跨域请求 转自：https://www.jianshu.com/p/f880878c1398 概述 在 HTML 中，\u0026lt;a\u0026gt;, \u0026lt;form\u0026gt;, \u0026lt;img\u0026gt;, \u0026lt;script\u0026gt;, \u0026lt;iframe\u0026gt;, \u0026lt;link\u0026gt; 等","title":"跨域请求"},{"content":"如果服务已经开始需要先停止服务，并删除旧的网络。 sudo service docker stop sudo ip link set dev docker0 down sudo brctl delbr docker0 创建自定义docker0 sudo brctl addbr docker0 sudo ip addr add 192.188.0.1/16 dev docker0 sudo ip link set dev docker0 up 重启docker sudo service docker restart ","permalink":"https://sqdtss.github.io/posts/docker%E8%87%AA%E5%AE%9A%E4%B9%89%E9%BB%98%E8%AE%A4%E7%BD%91%E6%A1%A5docker0/","summary":"如果服务已经开始需要先停止服务，并删除旧的网络。 sudo service docker stop sudo ip link set dev docker0 down sudo brctl delbr docker0 创建自定义docker0 sudo brctl addbr docker0 sudo ip addr add 192.188.0.1/16 dev docker0 sudo ip link set dev docker0 up 重","title":"docker自定义默认网桥docker0"},{"content":"1.标题设置 在标题文字前加#，一级标题为#，二级标题为##，三级标题为###，以此类推，最多六级，其中一级标题文字最大。\n一级标题 二级标题 三级标题 四级标题 五级标题 六级标题 2.引用块  \u0026gt;在一段文字前表示引用\n 3.文字 文字斜体 文字加粗 *文字左右各加一个*代表斜体，左右各加两个*代表加粗，其中*可以使用_代替\n删除线 在文字左右分别加两个~\n下划线下划线使用html实现，markdown本身没有下划线语法，如\u0026lt;u\u0026gt;\u0026lt;/u\u0026gt;\n文字内容 在文字左右加一个`\n4.列表 无序列表：文字前添加一个*或者+或者-和一个空格\n 111 222 333  有序列表：罗马数字和英文句号和一个空格\n hello 你好 hi  5. 超链接 内联方式：文字 [文字](网址链接)\n引用方式：\n[文字][1]\n在文章尾部[1]:网址链接\n6.图片 ![文字内容]() 括号内为图片名称，图片需要和.md文件放在一起，或者为网络位置。\n不建议使用代码及文件路径方式，可以使用编辑器功能图标上传网络位置图片或者本地图片。\n7.表格 |文字|文字|文字|\n|:\u0026mdash;\u0026ndash;|\u0026mdash;\u0026ndash;:|:\u0026mdash;\u0026ndash;:|\n|文字|文字|文字|\n|文字|文字|文字|\n注： :\u0026mdash;代表左对齐，\u0026mdash;:代表右对齐，:\u0026mdash;:代表居中对齐，-数目至少一个，:没有默认左对齐，第二行必须有，否则不是表格形式。以上格式代表是三行三列的表格。\n   1 2 3           8. 代码块 第一种：简单文字出现一个代码框。使用代码区。```要单独一行（不是单引号而是左上角的ESC下面~中的）。\n第二种：大片文字需要实现代码框，文字前按键盘Tab键。\ndef hello(): ​ print(\u0026quot;hello world\u0026quot;) 9.脚注 文字内容[^1]\n在文章末尾[^1]:脚注说明文字\n注：1可以为任意数字或文字或单词，但文章末尾[^]中内容与文中应保持一致\n","permalink":"https://sqdtss.github.io/posts/markdown%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AF%AD%E6%B3%95/","summary":"1.标题设置 在标题文字前加#，一级标题为#，二级标题为##，三级标题为###，以此类推，最多六级，其中一级标题文字最大。 一级标题 二级标题 三级","title":"markdown的使用语法"},{"content":"在logging.info()之前添加一行代码：logging.getLogger().setLevel(logging.INFO) ","permalink":"https://sqdtss.github.io/posts/python%E4%BD%BF%E7%94%A8logging.info%E6%96%B9%E6%B3%95%E7%BB%88%E7%AB%AF%E4%B8%8D%E6%98%BE%E7%A4%BA/","summary":"在logging.info()之前添加一行代码：logging.getLogger().setLevel(logging.INFO)","title":"Python使用logging.info()方法终端不显示"}]