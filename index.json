[{"content":"线段树将区间分成若干个子区间，子区间又继续分，直到区间为一个点（区间左值等于右值。 对于父区间[a,b]，其子区间为[a,(a+b)/2]和[(a+b)/2+1,b]，用于求区间的值，如区间最值、区间的和等。 代码实现中，约定结点下标从1开始，所以某结点下标为x，那么左儿子下标为2x，右儿子下标为2x+1，父结点下标为x/2。 |:常用符号:| |:符号:|:等价:|:意义:| |:rt\u0026laquo;1:|:rt2:|:左子树的编号:| |:rt\u0026laquo;1|1:|:rt2+1:|:右子树的编号:| |:(l+r)\u0026raquo;1:|:(l+r)/2:|:区间长度的一半:|\n常用宏定义\n#define Mid ((l+r)\u0026gt;\u0026gt;1) //注意括号 #define lson rt\u0026lt;\u0026lt;1,l,Mid\t//左结点 #define rson rt\u0026lt;\u0026lt;1|1,Mid+1,r\t//右结点 建树 建树丛根结点开始，递归建立左右子树，直到叶子结点，然后反向赋值，父结点的值 = F(左结点的值，右结点的值），这个F是依据题意变的，如果是区间最大则为max()\nvoid build(int rt,int l,int r) //建编号为rt的区间为[l,r]的树，主函数传进来的固定是(1,1,n) { if(l==r){ //叶子结点赋初值，注意下标，Max的是编号，val原数组的是l，看图可以理解  Max[rt] = val[l]; }else{ //建左右子树  build(lson); build(rson); Max[rt] = max( Max[rt\u0026lt;\u0026lt;1], Max[rt\u0026lt;\u0026lt;1|1]); //父结点Max值为Max(左子结点，右子结点）  } } 查询 查询为区间查询（只是查询某个点的话不需要线段树），即在区间里查询某个特性值，每次查询都是从跟结点开始往下，根据查询区间和当前区间的区间位置判断是要去左右子区间查询，还是直接返回。如果被查询区间是查询区间的子区间则直接返回子区间的值，如在[1,6]里查询[1,12]就返回[1,6]的值，不再往下查询。\nvoid query(int rt,int l,int r,int L,int R) //在[l,r]里查询[L,R]的值，[L,R]一直不变，[l,r]变 { if(L \u0026lt;= l \u0026amp;\u0026amp; r \u0026lt;= R){ ans1 = max(ans1,Max[rt]); ans2 = min(ans2,Min[rt]); }else{ if( L \u0026lt;= Mid) //查询区间在当前区间的左半区间有内容，如在[1,6]里查询[2,3]  query(lson,L,R); if( R \u0026gt; Mid) //同理去右子区间，注意不能有else，因为有横跨左右的情况，如[1,6]里查询[2,5]  query(rson,L,R); } } 更新 更新分为单点更新和区间更新，区间更新等会在下面讲述，而单点更新跟普通区间查询差不多\nvoid update(int rt,int l,int r,int pos,int num) { if(l == r \u0026amp;\u0026amp; r == pos){ //到对应的叶结点  Max[rt] = num; }else{ if( pos \u0026lt;= Mid) update(lson,pos,num); if( pos \u0026gt; Mid) //或者直接else，点不可能同时在两个区间里  update(rson,pos,num); Max[rt] = max( Max[rt\u0026lt;\u0026lt;1], Max[rt\u0026lt;\u0026lt;1|1]); } } 数组大小要为原数据范围的4倍，证明可自行百度。\n题目 POJ 3264 Balanced Lineup 求区间的最大值-最小值\n#include \u0026lt;cstdio\u0026gt;#include \u0026lt;cmath\u0026gt;#include \u0026lt;iostream\u0026gt;using namespace std; #define FOR( i , a , b ) for ( int i = a ; i \u0026lt;= b ; ++ i ) #define RE freopen(\u0026#34;1.in\u0026#34;,\u0026#34;r\u0026#34;,stdin); #define bug(x) cout\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34;:\u0026#34;\u0026lt;\u0026lt;(x)\u0026lt;\u0026lt;endl;  #define Mid ((l+r)\u0026gt;\u0026gt;1) //括号！ #define lson rt\u0026lt;\u0026lt;1,l,Mid #define rson rt\u0026lt;\u0026lt;1|1,Mid+1,r  const int maxn= 50005; const int inf=0x3f3f3f3f; int Max[maxn\u0026lt;\u0026lt;2],Min[maxn\u0026lt;\u0026lt;2]; int ans1,ans2; void build(int rt,int l,int r) { if(l==r){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;Max[rt]); Min[rt] = Max[rt]; }else{ build(lson); build(rson); Max[rt] = max( Max[rt\u0026lt;\u0026lt;1], Max[rt\u0026lt;\u0026lt;1|1]); Min[rt] = min( Min[rt\u0026lt;\u0026lt;1], Min[rt\u0026lt;\u0026lt;1|1]); } } void query(int rt,int l,int r,int L,int R) { if(L \u0026lt;= l \u0026amp;\u0026amp; r \u0026lt;= R){ ans1 = max(ans1,Max[rt]); ans2 = min(ans2,Min[rt]); }else{ if( L \u0026lt;= Mid) query(lson,L,R); if( R \u0026gt; Mid) query(rson,L,R); } } int main() { int n,m,L,R; while(scanf(\u0026#34;%d%d\u0026#34;,\u0026amp;n,\u0026amp;m)!=EOF){ build(1,1,n); while(m--){ ans1 = -inf,ans2 = inf; scanf(\u0026#34;%d%d\u0026#34;,\u0026amp;L,\u0026amp;R); query(1,1,n,L,R); printf(\u0026#34;%d\\n\u0026#34;, ans1-ans2); } } return 0; } HDU 1754 I Hate It 单点更新，区间查询最大\n#include \u0026lt;cstdio\u0026gt;#include \u0026lt;cmath\u0026gt;#include \u0026lt;iostream\u0026gt;using namespace std; #define FOR( i , a , b ) for ( int i = a ; i \u0026lt;= b ; ++ i ) #define RE freopen(\u0026#34;1.in\u0026#34;,\u0026#34;r\u0026#34;,stdin); #define bug(x) cout\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34;:\u0026#34;\u0026lt;\u0026lt;(x)\u0026lt;\u0026lt;endl;  #define Mid ((l+r)\u0026gt;\u0026gt;1) #define lson rt\u0026lt;\u0026lt;1,l,Mid #define rson rt\u0026lt;\u0026lt;1|1,Mid+1,r  const int maxn= 200000+5; const int inf=0x3f3f3f3f; int Max[maxn\u0026lt;\u0026lt;2]; int ans1,ans2; void build(int rt,int l,int r) { if(l==r){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;Max[rt]); }else{ build(lson); build(rson); Max[rt] = max( Max[rt\u0026lt;\u0026lt;1], Max[rt\u0026lt;\u0026lt;1|1]); } } void update(int rt,int l,int r,int pos,int num) { if(l == r \u0026amp;\u0026amp; r == pos){ Max[rt] = num; }else{ if( pos \u0026lt;= Mid) update(lson,pos,num); if( pos \u0026gt; Mid) update(rson,pos,num); Max[rt] = max( Max[rt\u0026lt;\u0026lt;1], Max[rt\u0026lt;\u0026lt;1|1]); } } int query(int rt,int l,int r,int L,int R) { if(L \u0026lt;= l \u0026amp;\u0026amp; r \u0026lt;= R){ return Max[rt]; }else{ int tmp = -1; if( L \u0026lt;= Mid) tmp = max(tmp,query(lson,L,R)); if( R \u0026gt; Mid) tmp = max(tmp,query(rson,L,R)); return tmp; } } int main() { // RE  int n,m,L,R; char op; while(scanf(\u0026#34;%d%d\u0026#34;,\u0026amp;n,\u0026amp;m)!=EOF){ build(1,1,n); getchar(); while(m--){ scanf(\u0026#34;%c%d%d%*c\u0026#34;,\u0026amp;op,\u0026amp;L,\u0026amp;R); if(op==\u0026#39;Q\u0026#39;) printf(\u0026#34;%d\\n\u0026#34;,query(1,1,n,L,R)); else update(1,1,n,L,R); } } return 0; } HDU 1166 敌兵布阵 单点更新，查询区间和\n#include \u0026lt;cstdio\u0026gt;#include \u0026lt;cmath\u0026gt;#include \u0026lt;iostream\u0026gt;using namespace std; #define FOR( i , a , b ) for ( int i = a ; i \u0026lt;= b ; ++ i ) #define RE freopen(\u0026#34;1.in\u0026#34;,\u0026#34;r\u0026#34;,stdin); #define bug(x) cout\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34;:\u0026#34;\u0026lt;\u0026lt;(x)\u0026lt;\u0026lt;endl;  #define Mid ((l+r)\u0026gt;\u0026gt;1) #define lson rt\u0026lt;\u0026lt;1,l,Mid #define rson rt\u0026lt;\u0026lt;1|1,Mid+1,r  const int maxn= 50000+5; const int inf=0x3f3f3f3f; int sum[maxn\u0026lt;\u0026lt;2]; int ans1,ans2; void build(int rt,int l,int r) { if(l==r){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;sum[rt]); }else{ build(lson); build(rson); sum[rt] = sum[rt\u0026lt;\u0026lt;1] + sum[rt\u0026lt;\u0026lt;1|1]; } } void update(int rt,int l,int r,int pos,int num) { if(l == r \u0026amp;\u0026amp; r == pos){ sum[rt] += num; }else{ if( pos \u0026lt;= Mid) update(lson,pos,num); else update(rson,pos,num); sum[rt] = sum[rt\u0026lt;\u0026lt;1] + sum[rt\u0026lt;\u0026lt;1|1]; } } int query(int rt,int l,int r,int L,int R) { if(L \u0026lt;= l \u0026amp;\u0026amp; r \u0026lt;= R){ return sum[rt]; }else{ int tmp = 0; if( L \u0026lt;= Mid) tmp += query(lson,L,R); if( R \u0026gt; Mid) tmp += query(rson,L,R); return tmp; } } int main() { // RE  int n,m,L,R,t; char op[10]; scanf(\u0026#34;%d\u0026#34;,\u0026amp;t); for(int cas=1;cas\u0026lt;=t;cas++){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); build(1,1,n); printf(\u0026#34;Case %d:\\n\u0026#34;,cas); while(scanf(\u0026#34;%s\u0026#34;,op),op[0]!=\u0026#39;E\u0026#39;){ scanf(\u0026#34;%d%d\u0026#34;,\u0026amp;L,\u0026amp;R); if(op[0]==\u0026#39;Q\u0026#39;) printf(\u0026#34;%d\\n\u0026#34;, query(1,1,n,L,R)); else if(op[0]==\u0026#39;A\u0026#39;) update(1,1,n,L,R); else update(1,1,n,L,-R); } } return 0; } Lazy思想 区间成段更新 Lazy：正常来说，区间改值，当更改某个区间的值的时候，子区间也该跟着更改，这样容易TLE。 Lazy思想就是更新到某个区间的时候，就先给这个区间打上标记，标记内容是需要更新的值，并把子区间的值改为子区间对应的值，清除该区间的lazy标记；然后return，不去更新子区间。当下一次更新或查询等需要访问该区间的子区间的时候再把该区间的lazy和其他信息送回子区间。\n举个简单粗暴的例子： 对应下面的那个图，假如目的是求和，现在要给[1,6] 的值都加2，那么我们从[1,12]-\u0026gt;[1,6]，然后[1,6]的sum值加上区间长度[ (6-1+1)*2 ]，再把[1,6]的add[i]设置为2，就不再往下更新了【这里极大提高效率】。下一次更新/查询[1,6]的子区间时，我们将[1,6]原存的add值下传给[1,6]的两个直接子区间，再往下更新。假设在这种情况下，我们再更新[1,6]加3，则[1,6]的add值为2+3=5，然后我们查询[1,3]，则从上往下经过[1,6]时把[1,6]的add值给了子区间[1,3]和[4,6]，同时把sum[子区间]跟着子区间长度和add[父结点]改动，清除add[父节点]。【如果是查询间接子区间，则连续传递add值，也就是连续pushDown】\n详细例子：假设update()是区间改值，query()是求和，所有叶子区间的和都为1，则[7,8]和[7,9]在build()的时候就附上了值（图中绿色字体）。假设此时我们更新[7,9]的值，改为2，则线段树从[1,12]-\u0026gt;[7,12]-\u0026gt;[7,9]，然后把[7,9]打上值为2的标记，求和（求和直接用区间长度*此时更新的值），然后不去更新[7,8]和[9,9]了，他们值仍然是2和1，lazy值为0。 然后我们查询[7,8]，当遍历经过[7,9]时:\nif(add[i]) pushDown(i); 成立，把[7,9]的lazy标记2传给子区间[7,8]和[9,9],分别求这2个子区间的和，把[7,9]的lazy标记去掉，然后继续遍历，到[7,8]的时候直接返回答案。 HDU 1698 Just a Hook 区间改值，求和\n#include \u0026lt;cstdio\u0026gt;#include \u0026lt;cmath\u0026gt;#include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt;using namespace std; #define ll long long #define FOR( i , a , b ) for ( int i = a ; i \u0026lt;= b ; ++ i ) #define RE freopen(\u0026#34;1.in\u0026#34;,\u0026#34;r\u0026#34;,stdin); #define WE freopen(\u0026#34;1.out\u0026#34;,\u0026#34;w\u0026#34;,stdout); #define MOD 10009 #define bug(x) cout\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34;:\u0026#34;\u0026lt;\u0026lt;(x)\u0026lt;\u0026lt;endl;  #define Mid ((l+r)\u0026gt;\u0026gt;1) #define lson rt\u0026lt;\u0026lt;1,l,Mid #define rson rt\u0026lt;\u0026lt;1|1,Mid+1,r const int maxn = 100010; int sum[maxn\u0026lt;\u0026lt;2],add[maxn\u0026lt;\u0026lt;2]; void build(int rt,int l,int r) { add[rt] = 0; if(l == r){ sum[rt] = 1; }else{ build(lson); build(rson); sum[rt]=sum[rt\u0026lt;\u0026lt;1]+sum[rt\u0026lt;\u0026lt;1|1]; } } void pushDown(int rt,int len) { add[rt\u0026lt;\u0026lt;1] = add[rt\u0026lt;\u0026lt;1|1] = add[rt]; sum[rt\u0026lt;\u0026lt;1] = (len-(len\u0026gt;\u0026gt;1))*add[rt]; sum[rt\u0026lt;\u0026lt;1|1] = (len\u0026gt;\u0026gt;1)*add[rt]; add[rt] = 0; } void update(int rt,int l,int r,int L,int R,int z) { if(L \u0026lt;= l \u0026amp;\u0026amp; r \u0026lt;= R){ add[rt] = z; sum[rt] = (r-l+1)*z; }else{ if(add[rt]) pushDown(rt,r-l+1); if(L \u0026lt;= Mid) update(lson,L,R,z); if(R \u0026gt; Mid) update(rson,L,R,z); sum[rt] = sum[rt\u0026lt;\u0026lt;1] + sum[rt\u0026lt;\u0026lt;1|1]; } } int main() { // RE;  int t,n,q,x,y,z; int cnt=1; scanf(\u0026#34;%d\u0026#34;,\u0026amp;t); while(t--){ scanf(\u0026#34;%d%d\u0026#34;,\u0026amp;n,\u0026amp;q); build(1,1,n); while(q--){ scanf(\u0026#34;%d%d%d\u0026#34;,\u0026amp;x,\u0026amp;y,\u0026amp;z); update(1,1,n,x,y,z); } printf(\u0026#34;Case %d: The total value of the hook is %d.\\n\u0026#34;, cnt++,sum[1]); } return 0; } ","permalink":"https://sqdtss.github.io/posts/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%85%A5%E9%97%A8/","summary":"线段树将区间分成若干个子区间，子区间又继续分，直到区间为一个点（区间左值等于右值。 对于父区间[a,b]，其子区间为[a,(a+b)/2]和[","title":"线段树入门 \u0026 lazy思想"},{"content":"Pytorch在保存模型时，会把训练过程中使用的设备号（GPU:0, CPU等）也一起保存下来，当load保存的模型时，会默认把权重加载到训练时使用的设备上，要修改加载到的卡号可以如下：\ntorch.load('your_model.pth', map_location=lambda storage, loc : storage.cuda(1))\n","permalink":"https://sqdtss.github.io/posts/pytorch%E8%BD%BD%E5%85%A5%E4%BF%9D%E5%AD%98%E7%9A%84%E6%A8%A1%E5%9E%8B%E6%9B%B4%E6%8D%A2gpu%E5%8D%A1%E5%8F%B7%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AEmap_location/","summary":"Pytorch在保存模型时，会把训练过程中使用的设备号（GPU:0, CPU等）也一起保存下来，当load保存的模型时，会默认把权重加载到训练","title":"Pytorch载入保存的模型更换gpu卡号如何设置map_location"},{"content":"什么是跨域请求 转自：https://www.jianshu.com/p/f880878c1398 概述 在 HTML 中，\u0026lt;a\u0026gt;, \u0026lt;form\u0026gt;, \u0026lt;img\u0026gt;, \u0026lt;script\u0026gt;, \u0026lt;iframe\u0026gt;, \u0026lt;link\u0026gt; 等标签以及 Ajax 都可以指向一个资源地址，而所谓的跨域请求就是指：当前发起请求的域与该请求指向的资源所在的域不一样。这里的域指的是这样的一个概念：若协议 + 域名 + 端口号均相同，那么就是同域。\n跨域请求的安全问题 通常，浏览器会对上面提到的跨域请求作出限制。浏览器之所以要对跨域请求作出限制，是出于安全方面的考虑，因为跨域请求有可能被不法分子利用来发动 CSRF攻击。\nCSRF（Cross-site request forgery），中文名称：跨站请求伪造，也被称为：one click attack/session riding，缩写为：CSRF/XSRF。CSRF攻击者在用户已经登录目标网站之后，诱使用户访问一个攻击页面，利用目标网站对用户的信任，以用户身份在攻击页面对目标网站发起伪造用户操作的请求，达到攻击目的。\n跨域解决方法 虽然在安全层面上同源限制是必要的，但有时同源策略会对我们的合理用途造成影响，为了避免开发的应用受到限制，有多种方式可以绕开同源策略，下面介绍的是经常使用的 JSONP, CORS 方法。\nJSONP 原理：  JSONP 是一种非官方的跨域数据交互协议 JSONP 本质上是利用 \u0026lt;script\u0026gt;\u0026lt;img\u0026gt;\u0026lt;iframe\u0026gt; 等标签不受同源策略限制，可以从不同域加载并执行资源的特性，来实现数据跨域传输。 JSONP由两部分组成：回调函数和数据。回调函数是当响应到来时应该在页面中调用的函数，而数据就是传入回调函数中的JSON数据。 JSONP 的理念就是，与服务端约定好一个回调函数名，服务端接收到请求后，将返回一段 Javascript，在这段 Javascript 代码中调用了约定好的回调函数，并且将数据作为参数进行传递。当网页接收到这段 Javascript 代码后，就会执行这个回调函数，这时数据已经成功传输到客户端了。  示例： 首先当前页面中声明有这样的一个函数，它将作为 JSONP 的回调函数处理作为函数参数传入的数据\n\u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; function dosomething(jsondata){ //处理获得的json数据 } \u0026lt;/script\u0026gt; 然后，我们就可以借助 \u0026lt;script\u0026gt;\u0026lt;img\u0026gt;\u0026lt;iframe\u0026gt; 等标签可以引入不同域资源的特性，将需要发送的请求的路径作为src参数，其中需要注意的是：需要告知服务端回调函数的函数名。\n\u0026lt;script src=\u0026#34;http://example.com/data.php?callback=dosomething\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 这时服务端在返回数据的时候，就会返回一端 Javascript 代码，在 Javascript代码中调用了回调函数，并且需要返回的数据作为回调函数的参数\ndosomething([\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;c\u0026#39;]); 最后页面成功加载了刚才指定路径的资源后，将会执行该 Javascript 代码，dosomething函数将执行，这时一次跨域请求完成。\n另外，如果页面引入了 jQuery，那么可以通过它封装的方法很方便的实现JSONP操作了\n// Using YQL and JSONP $.ajax({ url: \u0026#34;http://query.yahooapis.com/v1/public/yql\u0026#34;, // The name of the callback parameter, as specified by the YQL service  jsonp: \u0026#34;callback\u0026#34;, // Tell jQuery we\u0026#39;re expecting JSONP  dataType: \u0026#34;jsonp\u0026#34;, // Tell YQL what we want and that we want JSON  data: { q: \u0026#34;select title,abstract,url from search.news where query=\\\u0026#34;cat\\\u0026#34;\u0026#34;, format: \u0026#34;json\u0026#34; }, // Work with the response  success: function( response ) { console.log( response ); // server response  } }); 优缺点： JSONP 的优点是：它不像XMLHttpRequest对象实现的Ajax请求那样受到同源策略的限制；它的兼容性更好，在更加古老的浏览器中都可以运行。\nJSONP 的缺点是：它只支持 GET 请求，而不支持 POST 请求等其他类型的 HTTP 请求\nCORS 介绍 跨源资源共享 Cross-Origin Resource Sharing(CORS) 是一个新的 W3C 标准，它新增的一组HTTP首部字段，允许服务端其声明哪些源站有权限访问哪些资源。换言之，它允许浏览器向声明了 CORS 的跨域服务器，发出 XMLHttpReuest 请求，从而克服 Ajax 只能同源使用的限制。\n另外，规范也要求对于非简单请求，浏览器必须首先使用 OPTION 方法发起一个预检请求(preflight request)，从而获知服务端是否允许该跨域请求，在服务器确定允许后，才发起实际的HTTP请求。对于简单请求、非简单请求以及预检请求的详细资料可以阅读HTTP访问控制（CORS） 。\nHTTP 协议 Header 简析 下面对 CORS 中新增的 HTTP 首部字段进行简析：\n  Access-Control-Allow-Origin\n响应首部中可以携带这个头部表示服务器允许哪些域可以访问该资源，其语法如下：\nAccess-Control-Allow-Origin: \u0026lt;origin\u0026gt; | * 其中，origin 参数的值指定了允许访问该资源的外域 URI。对于不需要携带身份凭证的请求，服务器可以指定该字段的值为通配符，表示允许来自所有域的请求。\n  Access-Control-Allow-Methods\n该首部字段用于预检请求的响应，指明实际请求所允许使用的HTTP方法。其语法如下：\nAccess-Control-Allow-Methods: \u0026lt;method\u0026gt;[, \u0026lt;method\u0026gt;]*   Access-Control-Allow-Headers\n该首部字段用于预检请求的响应。指明了实际请求中允许携带的首部字段。其语法如下：\nAccess-Control-Allow-Headers: \u0026lt;field-name\u0026gt;[, \u0026lt;field-name\u0026gt;]*   Access-Control-Max-Age\n该首部字段用于预检请求的响应，指定了预检请求能够被缓存多久，其语法如下：\nAccess-Control-Max-Age: \u0026lt;delta-seconds\u0026gt;   Access-Control-Allow-Credentials\n该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。其语法如下：\nAccess-Control-Allow-Credentials: true 另外，如果要把 Cookie 发送到服务器，除了服务端要带上Access-Control-Allow-Credentials首部字段外，另一方面请求中也要带上withCredentials属性。\n但是需要注意的是：如果需要在 Ajax 中设置和获取 Cookie，那么Access-Control-Allow-Origin首部字段不能设置为* ，必须设置为具体的 origin 源站。详细可阅读文章CORS 跨域 Cookie 的设置与获取\n  Origin\n该首部字段表明预检请求或实际请求的源站。不管是否为跨域请求，Origin字段总是被发送。其语法如下：\nOrigin: \u0026lt;origin\u0026gt;   Access-Control-Request-Method\n该首部字段用于预检请求。其作用是，将实际请求所使用的 HTTP 方法告诉服务器。其语法如下：\nAccess-Control-Request-Method: \u0026lt;method\u0026gt;   Access-Control-Request-Headers\n该首部字段用于预检请求。其作用是，将实际请求所携带的首部字段告诉服务器。其语法如下：\nAccess-Control-Request-Headers: \u0026lt;field-name\u0026gt;[, \u0026lt;field-name\u0026gt;]*   与 JSONP 的比较  JSONP 只能实现 GET 请求，而 CORS 支持所有类型的 HTTP 请求 使用 CORS ，开发者可以是使用普通的 XMLHttpRequest 发起请求和获取数据，比起 JSONP 有更好的错误处理 虽然绝大多数现代的浏览器都已经支持 CORS，但是 CORS 的兼容性比不上 JSONP，一些比较老的浏览器只支持 JSONP  Reference  Http跨域请求 浅谈CSRF攻击方式 同源策略详解 详解js跨域问题 HTTP访问控制（CORS） 跨域资源共享 CORS 详解  ","permalink":"https://sqdtss.github.io/posts/%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82/","summary":"什么是跨域请求 转自：https://www.jianshu.com/p/f880878c1398 概述 在 HTML 中，\u0026lt;a\u0026gt;, \u0026lt;form\u0026gt;, \u0026lt;img\u0026gt;, \u0026lt;script\u0026gt;, \u0026lt;iframe\u0026gt;, \u0026lt;link\u0026gt; 等","title":"跨域请求"},{"content":"如果服务已经开始需要先停止服务，并删除旧的网络。 sudo service docker stop sudo ip link set dev docker0 down sudo brctl delbr docker0 创建自定义docker0 sudo brctl addbr docker0 sudo ip addr add 192.188.0.1/16 dev docker0 sudo ip link set dev docker0 up 重启docker sudo service docker restart ","permalink":"https://sqdtss.github.io/posts/docker%E8%87%AA%E5%AE%9A%E4%B9%89%E9%BB%98%E8%AE%A4%E7%BD%91%E6%A1%A5docker0/","summary":"如果服务已经开始需要先停止服务，并删除旧的网络。 sudo service docker stop sudo ip link set dev docker0 down sudo brctl delbr docker0 创建自定义docker0 sudo brctl addbr docker0 sudo ip addr add 192.188.0.1/16 dev docker0 sudo ip link set dev docker0 up 重","title":"docker自定义默认网桥docker0"},{"content":"1.标题设置 在标题文字前加#，一级标题为#，二级标题为##，三级标题为###，以此类推，最多六级，其中一级标题文字最大。\n一级标题 二级标题 三级标题 四级标题 五级标题 六级标题 2.引用块  \u0026gt;在一段文字前表示引用\n 3.文字 文字斜体 文字加粗 *文字左右各加一个*代表斜体，左右各加两个*代表加粗，其中*可以使用_代替\n删除线 在文字左右分别加两个~\n下划线下划线使用html实现，markdown本身没有下划线语法，如\u0026lt;u\u0026gt;\u0026lt;/u\u0026gt;\n文字内容 在文字左右加一个`\n4.列表 无序列表：文字前添加一个*或者+或者-和一个空格\n 111 222 333  有序列表：罗马数字和英文句号和一个空格\n hello 你好 hi  5. 超链接 内联方式：文字 [文字](网址链接)\n引用方式：\n[文字][1]\n在文章尾部[1]:网址链接\n6.图片 ![文字内容]() 括号内为图片名称，图片需要和.md文件放在一起，或者为网络位置。\n不建议使用代码及文件路径方式，可以使用编辑器功能图标上传网络位置图片或者本地图片。\n7.表格 |文字|文字|文字|\n|:\u0026mdash;\u0026ndash;|\u0026mdash;\u0026ndash;:|:\u0026mdash;\u0026ndash;:|\n|文字|文字|文字|\n|文字|文字|文字|\n注： :\u0026mdash;代表左对齐，\u0026mdash;:代表右对齐，:\u0026mdash;:代表居中对齐，-数目至少一个，:没有默认左对齐，第二行必须有，否则不是表格形式。以上格式代表是三行三列的表格。\n   1 2 3           8. 代码块 第一种：简单文字出现一个代码框。使用代码区。```要单独一行（不是单引号而是左上角的ESC下面~中的）。\n第二种：大片文字需要实现代码框，文字前按键盘Tab键。\ndef hello(): ​ print(\u0026quot;hello world\u0026quot;) 9.脚注 文字内容[^1]\n在文章末尾[^1]:脚注说明文字\n注：1可以为任意数字或文字或单词，但文章末尾[^]中内容与文中应保持一致\n","permalink":"https://sqdtss.github.io/posts/markdown%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AF%AD%E6%B3%95/","summary":"1.标题设置 在标题文字前加#，一级标题为#，二级标题为##，三级标题为###，以此类推，最多六级，其中一级标题文字最大。 一级标题 二级标题 三级","title":"markdown的使用语法"},{"content":"在logging.info()之前添加一行代码：logging.getLogger().setLevel(logging.INFO) ","permalink":"https://sqdtss.github.io/posts/python%E4%BD%BF%E7%94%A8logging.info%E6%96%B9%E6%B3%95%E7%BB%88%E7%AB%AF%E4%B8%8D%E6%98%BE%E7%A4%BA/","summary":"在logging.info()之前添加一行代码：logging.getLogger().setLevel(logging.INFO)","title":"Python使用logging.info()方法终端不显示"},{"content":"Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/32768 K (Java/Others) Total Submission(s): 121643 Accepted Submission(s): 50879 Problem Description C国的死对头A国这段时间正在进行军事演习，所以C国间谍头子Derek和他手下Tidy又开始忙乎了。A国在海岸线沿直线布置了N个工兵营地,Derek和Tidy的任务就是要监视这些工兵营地的活动情况。由于采取了某种先进的监测手段，所以每个工兵营地的人数C国都掌握的一清二楚,每个工兵营地的人数都有可能发生变动，可能增加或减少若干人手,但这些都逃不过C国的监视。 中央情报局要研究敌人究竟演习什么战术,所以Tidy要随时向Derek汇报某一段连续的工兵营地一共有多少人,例如Derek问:“Tidy,马上汇报第3个营地到第10个营地共有多少人!”Tidy就要马上开始计算这一段的总人数并汇报。但敌兵营地的人数经常变动，而Derek每次询问的段都不一样，所以Tidy不得不每次都一个一个营地的去数，很快就精疲力尽了，Derek对Tidy的计算速度越来越不满:\u0026ldquo;你个死肥仔，算得这么慢，我炒你鱿鱼!”Tidy想：“你自己来算算看，这可真是一项累人的工作!我恨不得你炒我鱿鱼呢!”无奈之下，Tidy只好打电话向计算机专家Windbreaker求救,Windbreaker说：“死肥仔，叫你平时做多点acm题和看多点算法书，现在尝到苦果了吧!”Tidy说：\u0026ldquo;我知错了。。。\u0026ldquo;但Windbreaker已经挂掉电话了。Tidy很苦恼，这么算他真的会崩溃的，聪明的读者，你能写个程序帮他完成这项工作吗？不过如果你的程序效率不够高的话，Tidy还是会受到Derek的责骂的.\nInput 第一行一个整数T，表示有T组数据。 每组数据第一行一个正整数N（N\u0026lt;=50000）,表示敌人有N个工兵营地，接下来有N个正整数,第i个正整数ai代表第i个工兵营地里开始时有ai个人（1\u0026lt;=ai\u0026lt;=50）。 接下来每行有一条命令，命令有4种形式： (1) Add i j,i和j为正整数,表示第i个营地增加j个人（j不超过30） (2)Sub i j ,i和j为正整数,表示第i个营地减少j个人（j不超过30）; (3)Query i j ,i和j为正整数,i\u0026lt;=j，表示询问第i到第j个营地的总人数; (4)End 表示结束，这条命令在每组数据最后出现; 每组数据最多有40000条命令 Output 对第i组数据,首先输出“Case i:”和回车, 对于每个Query询问，输出一个整数并回车,表示询问的段中的总人数,这个数保持在int以内。 Sample Input 1 10 1 2 3 4 5 6 7 8 9 10 Query 1 3 Add 3 6 Query 2 7 Sub 10 2 Add 6 3 Query 3 10 End Sample Output Case 1: 6 33 59 分析：此题为经典线段树题， 也可以用树状数组来写，注意线段树的题用scanf， printf， 因为操作可能输入数据较多， 容易超时。 线段树ac代码：\n#include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; const int N=100000+10; int t, n, p = 0; struct segTree{ int l, r; int v; }T[N*4]; void Build(int l, int r, int k){ T[k].l = l, T[k].r = r; if(l == r){ scanf(\u0026#34;%d\u0026#34;, \u0026amp;T[k].v); return; } int mid = (l+r)/2; Build(l, mid, k*2); Build(mid+1, r, k*2+1); T[k].v = T[k*2].v + T[k*2+1].v; } void Update(int c, int v, int k){ if(T[k].l == T[k].r \u0026amp;\u0026amp; T[k].l == c){ T[k].v += v; return; } int mid = (T[k].l+T[k].r)/2; if(c \u0026lt;= mid) Update(c, v, k*2); else Update(c, v, k*2+1); T[k].v = T[k*2].v + T[k*2+1].v; } int ans; void Query(int l, int r, int k){ if(l \u0026gt; T[k].r || r \u0026lt; T[k].l){ return; } if(l \u0026lt;= T[k].l \u0026amp;\u0026amp; r \u0026gt;= T[k].r){ ans += T[k].v; return; } int mid = (T[k].l+T[k].r)/2; if(r \u0026lt; mid) Query(l, r, k*2); else if(l \u0026gt; mid) Query(l, r, k*2+1); else{ Query(l, mid, k*2); Query(mid+1, r, k*2+1); } } int main(){ scanf(\u0026#34;%d\u0026#34;, \u0026amp;t); while(t--){ scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); Build(1, n, 1); char op[10]; printf(\u0026#34;Case %d:\\n\u0026#34;, ++p); while(scanf(\u0026#34;%s\u0026#34;, op), op[0] != \u0026#39;E\u0026#39;){ int u, v; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;u, \u0026amp;v); if(op[0] == \u0026#39;A\u0026#39;){ Update(u, v, 1); } else if(op[0] == \u0026#39;S\u0026#39;){ Update(u, -v, 1); } else{ ans = 0; Query(u, v, 1); printf(\u0026#34;%d\\n\u0026#34;, ans); } } } } 树状数组ac代码：\n#include \u0026lt;iostream\u0026gt;#include\u0026lt;cstdio\u0026gt; #include\u0026lt;cstring\u0026gt;#define N 50005 using namespace std; int a[N],n; int lowbit(int x) { return x\u0026amp;(-x); } void Insert(int i,int x) { while(i\u0026lt;=n) { a[i]+=x; i+=lowbit(i); } } int getSum(int i) { int sum=0; while(i\u0026gt;0) { sum+=a[i]; i-=lowbit(i); } return sum; } int main() { char s[10]; int t,Case=1,m,b; cin\u0026gt;\u0026gt;t; while(t--) { cin\u0026gt;\u0026gt;n; memset(a,0,sizeof(a)); for(int i=1;i\u0026lt;=n;i++) { int n; cin\u0026gt;\u0026gt;n; Insert(i,n); } printf(\u0026#34;Case %d:\\n\u0026#34;,Case++); while(scanf(\u0026#34;%s\u0026#34;,s),strcmp(s,\u0026#34;End\u0026#34;)) { if(s[0]==\u0026#39;A\u0026#39;) { cin\u0026gt;\u0026gt;m\u0026gt;\u0026gt;b; Insert(m,b); } else if(s[0]==\u0026#39;S\u0026#39;) { cin\u0026gt;\u0026gt;m\u0026gt;\u0026gt;b; Insert(m,-b); } else if(s[0]==\u0026#39;Q\u0026#39;) { cin\u0026gt;\u0026gt;m\u0026gt;\u0026gt;b; cout\u0026lt;\u0026lt;getSum(b)-getSum(m-1)\u0026lt;\u0026lt;endl; } else break; } } return 0; } ","permalink":"https://sqdtss.github.io/posts/%E7%BA%BF%E6%AE%B5%E6%A0%91%E6%A8%A1%E6%9D%BF%E9%A2%98hdu1166/","summary":"Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/32768 K (Java/Others) Total Submission(s): 121643 Accepted Submission(s): 50879 Problem Description C国的死对头A国这段时间正在进行军事演习，所以C国间谍头子Derek和他手下Tidy又开始忙乎了。A国在","title":"线段树模板题 hdu 1166: 敌兵布阵"},{"content":"Time Limit: 9000/3000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others) Total Submission(s): 100523 Accepted Submission(s): 37845 Problem Description 很多学校流行一种比较的习惯。老师们很喜欢询问，从某某到某某当中，分数最高的是多少。这让很多学生很反感。 不管你喜不喜欢，现在需要你做的是，就是按照老师的要求，写一个程序，模拟老师的询问。当然，老师有时候需要更新某位同学的成绩。\nInput 本题目包含多组测试，请处理到文件结束。 在每个测试的第一行，有两个正整数 N 和 M ( 0\u0026lt;N\u0026lt;=200000,0\u0026lt;M\u0026lt;5000 )，分别代表学生的数目和操作的数目。 学生ID编号分别从1编到N。 第二行包含N个整数，代表这N个学生的初始成绩，其中第i个数代表ID为i的学生的成绩。 接下来有M行。每一行有一个字符 C (只取'Q'或'U') ，和两个正整数A，B。 当C为'Q'的时候，表示这是一条询问操作，它询问ID从A到B(包括A,B)的学生当中，成绩最高的是多少。 当C为'U'的时候，表示这是一条更新操作，要求把ID为A的学生的成绩更改为B。 Output 对于每一次询问操作，在一行里面输出最高成绩。 Sample Input 5 6 1 2 3 4 5 Q 1 5 U 3 6 Q 3 4 Q 4 5 U 2 9 Q 1 5 Sample Output 5 6 5 9 分析：此题为经典线段树模板题， 标志性的更新和查询操作， 如果无数条更新和查询操作时， 想到线段树， 很可能就是一道与此题类似的线段树题欧。。\nac代码：\n#include \u0026lt;iostream\u0026gt;#include \u0026lt;cstdio\u0026gt;#include \u0026lt;algorithm\u0026gt;using namespace std; const int N=200000+50; struct tree{ int l, r, maxn; }; tree t[N*3]; int ans; void build(int m, int l, int r) { t[m].l = l; t[m].r = r; if(l==r) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;t[m].maxn); return; } int mid = (l + r) \u0026gt;\u0026gt; 1; build(m\u0026lt;\u0026lt;1, l, mid); build(m\u0026lt;\u0026lt;1|1, mid+1, r); t[m].maxn = max(t[m\u0026lt;\u0026lt;1].maxn, t[m\u0026lt;\u0026lt;1|1].maxn); } void U(int m, int a, int b) { if(t[m].l == t[m].r \u0026amp;\u0026amp; t[m].l == a) { t[m].maxn = b; return; } int mid = (t[m].l + t[m].r) \u0026gt;\u0026gt; 1; if(a \u0026lt;= mid) U(m\u0026lt;\u0026lt;1, a, b); else U(m\u0026lt;\u0026lt;1|1, a, b); t[m].maxn = max(t[m\u0026lt;\u0026lt;1].maxn, t[m\u0026lt;\u0026lt;1|1].maxn); } void Q(int m, int l, int r) { if(t[m].l == l \u0026amp;\u0026amp; t[m].r == r) { ans = max(ans, t[m].maxn); return; } int mid = (t[m].l + t[m].r) \u0026gt;\u0026gt; 1; if(r \u0026lt;= mid) Q(m\u0026lt;\u0026lt;1, l, r); else if(l \u0026gt;= mid + 1) Q(m\u0026lt;\u0026lt;1|1, l, r); else { Q(m\u0026lt;\u0026lt;1, l, mid); Q(m\u0026lt;\u0026lt;1|1, mid+1, r); } } int main() { int n, m; while(scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m)!=EOF) { build(1, 1, n); for(int i=0;i\u0026lt;m;i++) { getchar(); char c; int a, b; scanf(\u0026#34;%c\u0026#34;, \u0026amp;c); scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;a, \u0026amp;b); if(c == \u0026#39;Q\u0026#39;) { ans = 0; Q(1, a, b); printf(\u0026#34;%d\\n\u0026#34;, ans); } else U(1, a, b); } } return 0; } ","permalink":"https://sqdtss.github.io/posts/%E7%BA%BF%E6%AE%B5%E6%A0%91%E6%A8%A1%E6%9D%BF%E9%A2%98hdu1754/","summary":"Time Limit: 9000/3000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others) Total Submission(s): 100523 Accepted Submission(s): 37845 Problem Description 很多学校流行一种比较的习惯。老师们很喜欢询问，从某某到某某当中，分数最高的是多少。这让很多学生很反感。 不","title":"线段树模板题 hdu 1754: I Hate It"}]